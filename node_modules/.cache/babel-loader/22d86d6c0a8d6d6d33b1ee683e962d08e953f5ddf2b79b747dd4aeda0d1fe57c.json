{"ast":null,"code":"import Papa from'papaparse';/**\n * Esta función carga los datos de Pokémon desde el CSV\n * @param {string} mapType - Tipo de mapa (HashMap, TreeMap, LinkedHashMap)\n * @returns {Promise<Object>} - Un objeto con los datos de Pokémon\n */export const fetchAllPokemons=async mapType=>{try{// En un caso real, haríamos una llamada a la API Java que hemos creado\n// Aquí simularemos cargar el CSV directamente (en producción se manejaría desde el backend)\nconst csvUrl=process.env.PUBLIC_URL+'/data/pokemon_data_pokeapi.csv';const response=await fetch(csvUrl);if(!response.ok){throw new Error(`No se pudo cargar el archivo: ${response.statusText}`);}const csvText=await response.text();// Convertir el CSV a un objeto según el tipo de Map\nreturn parseCSVToMap(csvText,mapType);}catch(error){console.error('Error en fetchAllPokemons:',error);throw error;}};/**\n * Convierte los datos CSV a un objeto según el tipo de Map seleccionado\n * @param {string} csvText - Texto CSV\n * @param {string} mapType - Tipo de Map (HashMap, TreeMap, LinkedHashMap)\n * @returns {Object} - Map de Pokémon\n */const parseCSVToMap=(csvText,mapType)=>{return new Promise((resolve,reject)=>{Papa.parse(csvText,{header:true,dynamicTyping:true,skipEmptyLines:true,complete:results=>{try{// Transformar los datos según el tipo de Map\nconst pokemonMap=createPokemonMap(results.data,mapType);resolve(pokemonMap);}catch(error){reject(error);}},error:error=>{reject(error);}});});};/**\n * Crea un Map de Pokémon según el tipo especificado\n * @param {Array} pokemonArray - Array de datos de Pokémon\n * @param {string} mapType - Tipo de Map a crear\n * @returns {Object} - Map de Pokémon\n */const createPokemonMap=(pokemonArray,mapType)=>{let pokemonMap={};switch(mapType){case\"HashMap\":// Un objeto normal en JavaScript (no garantiza orden)\npokemonMap=pokemonArray.reduce((map,pokemon)=>{map[pokemon.Name]=transformPokemonData(pokemon);return map;},{});break;case\"TreeMap\":// Simulamos TreeMap ordenando las claves alfabéticamente\nconst sorted=[...pokemonArray].sort((a,b)=>a.Name.localeCompare(b.Name));pokemonMap=sorted.reduce((map,pokemon)=>{map[pokemon.Name]=transformPokemonData(pokemon);return map;},{});break;case\"LinkedHashMap\":// Simulamos LinkedHashMap manteniendo el orden de inserción\npokemonMap=pokemonArray.reduce((map,pokemon)=>{map[pokemon.Name]=transformPokemonData(pokemon);return map;},{});break;default:throw new Error(`Tipo de mapa no válido: ${mapType}`);}return pokemonMap;};/**\n * Transforma los datos crudos del Pokémon al formato deseado\n * @param {Object} rawPokemon - Datos crudos del Pokémon desde el CSV\n * @returns {Object} - Datos del Pokémon transformados\n */const transformPokemonData=rawPokemon=>{return{name:rawPokemon.Name,type1:rawPokemon.Type1,type2:rawPokemon.Type2||\"\",total:rawPokemon.Total,hp:rawPokemon.HP,attack:rawPokemon.Attack,defense:rawPokemon.Defense,spAtk:rawPokemon[\"Sp. Atk\"],spDef:rawPokemon[\"Sp. Def\"],speed:rawPokemon.Speed,generation:rawPokemon.Generation,legendary:rawPokemon.Legendary===\"True\"||rawPokemon.Legendary===true,ability:rawPokemon.Ability||\"Unknown\"};};/**\n * Filtra los Pokémon por nombre\n * @param {Object} pokemons - Map de Pokémon\n * @param {string} searchTerm - Término de búsqueda\n * @returns {Array} - Array de Pokémon filtrados\n */export const searchPokemonsByName=(pokemons,searchTerm)=>{if(!searchTerm)return Object.values(pokemons);return Object.values(pokemons).filter(pokemon=>pokemon.name.toLowerCase().includes(searchTerm.toLowerCase()));};/**\n * Filtra los Pokémon por habilidad\n * @param {Object} pokemons - Map de Pokémon\n * @param {string} ability - Habilidad a buscar\n * @returns {Array} - Array de Pokémon filtrados\n */export const searchPokemonsByAbility=(pokemons,ability)=>{if(!ability)return Object.values(pokemons);return Object.values(pokemons).filter(pokemon=>pokemon.ability.toLowerCase().includes(ability.toLowerCase()));};/**\n * Ordena los Pokémon por tipo\n * @param {Array} pokemons - Array de Pokémon\n * @returns {Object} - Pokémon agrupados por tipo\n */export const getPokemonsByType=pokemons=>{return pokemons.reduce((groups,pokemon)=>{const type=pokemon.type1;if(!groups[type]){groups[type]=[];}groups[type].push(pokemon);return groups;},{});};","map":{"version":3,"names":["Papa","fetchAllPokemons","mapType","csvUrl","process","env","PUBLIC_URL","response","fetch","ok","Error","statusText","csvText","text","parseCSVToMap","error","console","Promise","resolve","reject","parse","header","dynamicTyping","skipEmptyLines","complete","results","pokemonMap","createPokemonMap","data","pokemonArray","reduce","map","pokemon","Name","transformPokemonData","sorted","sort","a","b","localeCompare","rawPokemon","name","type1","Type1","type2","Type2","total","Total","hp","HP","attack","Attack","defense","Defense","spAtk","spDef","speed","Speed","generation","Generation","legendary","Legendary","ability","Ability","searchPokemonsByName","pokemons","searchTerm","Object","values","filter","toLowerCase","includes","searchPokemonsByAbility","getPokemonsByType","groups","type","push"],"sources":["/Users/fatu/Documents/Progra /pokemon-explorer/frontend/src/services/PokemonService.js"],"sourcesContent":["import Papa from 'papaparse';\n\n/**\n * Esta función carga los datos de Pokémon desde el CSV\n * @param {string} mapType - Tipo de mapa (HashMap, TreeMap, LinkedHashMap)\n * @returns {Promise<Object>} - Un objeto con los datos de Pokémon\n */\nexport const fetchAllPokemons = async (mapType) => {\n  try {\n    // En un caso real, haríamos una llamada a la API Java que hemos creado\n    // Aquí simularemos cargar el CSV directamente (en producción se manejaría desde el backend)\n    const csvUrl = process.env.PUBLIC_URL + '/data/pokemon_data_pokeapi.csv';\n    \n    const response = await fetch(csvUrl);\n    if (!response.ok) {\n      throw new Error(`No se pudo cargar el archivo: ${response.statusText}`);\n    }\n    \n    const csvText = await response.text();\n    \n    // Convertir el CSV a un objeto según el tipo de Map\n    return parseCSVToMap(csvText, mapType);\n  } catch (error) {\n    console.error('Error en fetchAllPokemons:', error);\n    throw error;\n  }\n};\n\n/**\n * Convierte los datos CSV a un objeto según el tipo de Map seleccionado\n * @param {string} csvText - Texto CSV\n * @param {string} mapType - Tipo de Map (HashMap, TreeMap, LinkedHashMap)\n * @returns {Object} - Map de Pokémon\n */\nconst parseCSVToMap = (csvText, mapType) => {\n  return new Promise((resolve, reject) => {\n    Papa.parse(csvText, {\n      header: true,\n      dynamicTyping: true,\n      skipEmptyLines: true,\n      complete: (results) => {\n        try {\n          // Transformar los datos según el tipo de Map\n          const pokemonMap = createPokemonMap(results.data, mapType);\n          resolve(pokemonMap);\n        } catch (error) {\n          reject(error);\n        }\n      },\n      error: (error) => {\n        reject(error);\n      }\n    });\n  });\n};\n\n/**\n * Crea un Map de Pokémon según el tipo especificado\n * @param {Array} pokemonArray - Array de datos de Pokémon\n * @param {string} mapType - Tipo de Map a crear\n * @returns {Object} - Map de Pokémon\n */\nconst createPokemonMap = (pokemonArray, mapType) => {\n  let pokemonMap = {};\n  \n  switch(mapType) {\n    case \"HashMap\":\n      // Un objeto normal en JavaScript (no garantiza orden)\n      pokemonMap = pokemonArray.reduce((map, pokemon) => {\n        map[pokemon.Name] = transformPokemonData(pokemon);\n        return map;\n      }, {});\n      break;\n      \n    case \"TreeMap\":\n      // Simulamos TreeMap ordenando las claves alfabéticamente\n      const sorted = [...pokemonArray].sort((a, b) => \n        a.Name.localeCompare(b.Name)\n      );\n      \n      pokemonMap = sorted.reduce((map, pokemon) => {\n        map[pokemon.Name] = transformPokemonData(pokemon);\n        return map;\n      }, {});\n      break;\n      \n    case \"LinkedHashMap\":\n      // Simulamos LinkedHashMap manteniendo el orden de inserción\n      pokemonMap = pokemonArray.reduce((map, pokemon) => {\n        map[pokemon.Name] = transformPokemonData(pokemon);\n        return map;\n      }, {});\n      break;\n      \n    default:\n      throw new Error(`Tipo de mapa no válido: ${mapType}`);\n  }\n  \n  return pokemonMap;\n};\n\n/**\n * Transforma los datos crudos del Pokémon al formato deseado\n * @param {Object} rawPokemon - Datos crudos del Pokémon desde el CSV\n * @returns {Object} - Datos del Pokémon transformados\n */\nconst transformPokemonData = (rawPokemon) => {\n  return {\n    name: rawPokemon.Name,\n    type1: rawPokemon.Type1,\n    type2: rawPokemon.Type2 || \"\",\n    total: rawPokemon.Total,\n    hp: rawPokemon.HP,\n    attack: rawPokemon.Attack,\n    defense: rawPokemon.Defense,\n    spAtk: rawPokemon[\"Sp. Atk\"],\n    spDef: rawPokemon[\"Sp. Def\"],\n    speed: rawPokemon.Speed,\n    generation: rawPokemon.Generation,\n    legendary: rawPokemon.Legendary === \"True\" || rawPokemon.Legendary === true,\n    ability: rawPokemon.Ability || \"Unknown\"\n  };\n};\n\n/**\n * Filtra los Pokémon por nombre\n * @param {Object} pokemons - Map de Pokémon\n * @param {string} searchTerm - Término de búsqueda\n * @returns {Array} - Array de Pokémon filtrados\n */\nexport const searchPokemonsByName = (pokemons, searchTerm) => {\n  if (!searchTerm) return Object.values(pokemons);\n  \n  return Object.values(pokemons).filter(pokemon => \n    pokemon.name.toLowerCase().includes(searchTerm.toLowerCase())\n  );\n};\n\n/**\n * Filtra los Pokémon por habilidad\n * @param {Object} pokemons - Map de Pokémon\n * @param {string} ability - Habilidad a buscar\n * @returns {Array} - Array de Pokémon filtrados\n */\nexport const searchPokemonsByAbility = (pokemons, ability) => {\n  if (!ability) return Object.values(pokemons);\n  \n  return Object.values(pokemons).filter(pokemon => \n    pokemon.ability.toLowerCase().includes(ability.toLowerCase())\n  );\n};\n\n/**\n * Ordena los Pokémon por tipo\n * @param {Array} pokemons - Array de Pokémon\n * @returns {Object} - Pokémon agrupados por tipo\n */\nexport const getPokemonsByType = (pokemons) => {\n  return pokemons.reduce((groups, pokemon) => {\n    const type = pokemon.type1;\n    if (!groups[type]) {\n      groups[type] = [];\n    }\n    groups[type].push(pokemon);\n    return groups;\n  }, {});\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}